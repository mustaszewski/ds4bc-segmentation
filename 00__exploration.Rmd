---
title: "Exploration and RFM"
author:
  - "Aichinger-Fankhauser Peter"
  - "Beyerle Gregor"
  - "Reckmeyer Emanuel Elias"
  - "Ustaszewski Michael"
date: "2021-12-30"
output:
  html_document:
    df_print: paged
---

# Customer Segmentation Group Work

## Instructions

- Imagine you and your team mates have just founded a Data Science start up. Your
  first customer is a fundraising organization asking for support with regard to
  making most of their donor and transaction data.
- The Head of Fund Development who is your direct counterpart and project sponsor
  asks your team to come up with a segmentation of the donor base as quickly as
  possible. The manager has a basic understanding of RFM modelling and tells you
  that there was a simple model in use some years ago which was neither updated nor
  further developed.
- In general, your client organization is model-agnostic and trusts your judgment
  and consulting. However, the let you know that seeing alternative approaches in
  action together with your reflection, expertise and concluding recommendation
  how to process would be great ...
- The clients finally provide you with a flat file together with a list of
  feature descriptions ...

### Tasks

- Form a group of 3 to 4 persons
- Get accustomed to the data and have an explorative look at it.
- Think your variables that might be added to or derived from the dataset with
  relative ease, e.g. conducting some research, data enrichment etc.
- Take those down and formulate recommendations towards the client.
- If you find time and a viable data source, you may of course go ahead and
  enrich the dataset
- Apply at least two customer segmentation approaches to the provided data
- Model examples: RFM, k-Means-Algorithm
- Summarize the segmentation generated results and derived insights
- Compare the model outputs and formulate a recommendation for the customer

### Expected Output

- Deliverable: Pitch presentation
- Deadline: December 31th, 2021

```{r setup, include=FALSE}
source("code/dataset.R")

library(rfm)

knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)
```

## Preprocessing

The data set for this analysis contains 21 attributes that might or might not
contribute to how we would group donors. Most of them are related to whether there
were donations or merchandise purchases in a respective year. The code book gives
a complete picture of each attribute.

```{r}
feature_description_original <- readxl::read_excel(
  "data/feature_description.xlsx", col_names = c("Name", "Description"))

feature_description_original
```

The first inspection of the data is done with relatively unprocessed attributes.
A quick skim shows that more than a third of birth dates are missing and that around
11% of donors have only donated once. Other than that we see mostly skewed distributions
in the numerical variables with rather long tails.

```{r}
customer_segmentation_raw <- read_raw_customer_data("data/customer_segmentation_test.csv")

skimr::skim(customer_segmentation_raw)
```

### Feature Engineering

In order to extract more information out of the present variables we want to enrich
the existing data with additional information, calculate donation/merchandise
summaries and prepare the needed fields for a simple RFM analysis.

First, we start out with additional data we took from the Austrian Postal Services
who maintain lists of historical postal codes, historical town names and their most
recent counterparts. This gives us information about the towns and states for most
donors.

```{r}
customer_segmentation_with_zip <- enrich_with_postal_info(
  customer_segmentation_raw,
  "data/PLZ_Verzeichnis-20211201.xlsx"
)

customer_segmentation_with_zip
```

The additional feature engineering is applied to extract additional attributes like:

- Year of donor's birthday
- Age of donor at last donation
- Generational moniker (Pew Research Generation Names)
- Total count of donations
- Total donation amount
- Average donation amount per year
- Average amount of donations per year
- Last payment month
- Penultimate payment month
- Status if donor is a "Christmas Donor" or not
- Interval between last and penultimate donation in days
- Days since last payment
- Flag if there were any merchandise purchases over the years
- The number of years in which there were donations

```{r}
customer_segmentation_first_prepro <- apply_feature_engineering(customer_segmentation_with_zip)
skimr::skim(customer_segmentation_first_prepro)
```

```{r}
customer_segmentation_complete <- customer_segmentation_first_prepro %>% drop_na()
customer_segmentation_complete
```

For certain analyses it might be good to throw out all observations in which there
are NA values. This still leaves us with `r NROW(customer_segmentation_complete)` rows.

### Visual Exploration

Before looking into unsupervised learning methods it makes sense to build an intuition
for the data set using simple visuals. If there are very obvious patterns we might
be able to see it there. One of the first things we could inspect is whether the
different genders have different donations behaviors.

This hypothesis wouldn't be validated when looking at the number of "Christmas Donors"
 - meaning people who donate in December (or November/January) or during all other
 months of the year. We don't see widely different behaviors between the genders here
 but we can validate the notion that a big chunk of all donations are done in the winter
 months. Targetting people before the "giving seasons" could yield good results.

```{r}
ggplot(customer_segmentation_first_prepro, aes(XMAS_donor)) +
  geom_bar(fill = "#76B856") +
  facet_wrap(~Gender)
```

Looking at the patterns regarding the regularity with which people donate we wouldn't
see very apparent differences in the general patterns between genders as well. We see
that a large amount of donors donated only for one year.

```{r}
ggplot(customer_segmentation_first_prepro, aes(num_of_donation_years)) +
  geom_bar(fill = "#76B856") +
  facet_wrap(~Gender)
```

Looking at the donation sums we see a distribution favoring low amounts with very
long tails. They are so long in fact, that if we don't limit our visual analysis to
sums smaller than 3000 we don't see a lot. Looking at differences by gender we again
see rather similar patterns.

```{r}
ggplot(customer_segmentation_first_prepro %>% filter(SUMtotal > 0 & SUMtotal < 3000), aes(x = SUMtotal)) +
  geom_histogram(fill = "#76B856", color = "white", binwidth = 50) +
  facet_wrap(~Gender)
```

As we already saw with the "Christmas Donors" we can see that people give more in
the winter months. Again the different genders (at least the ones we distinguish
in this data set) behave rather similarly.

```{r}
ggplot(customer_segmentation_first_prepro, aes(LastPaymentMONTH)) +
  geom_bar(fill = "#76B856") +
  facet_wrap(~Gender)
```

It shouldn't be surprising that the same view on the penultimate payment date is
the view we had on the last payment month lagged by one month.

```{r}
ggplot(customer_segmentation_first_prepro, aes(PenultimatePaymentMONTH)) +
  geom_bar(fill = "#76B856") +
  facet_wrap(~Gender)
```

Looking at the different generations we can see that the older generations
(silent and boomer) have rather similar behaviors while the younger people donate
far less. This would make sense as older people have more expandable income. Also
looking at the general amount we only have very few samples of the young millenial
and z generation members.

```{r}
ggplot(customer_segmentation_complete, aes(num_of_donation_years)) +
  geom_bar(fill = "#76B856") +
  facet_wrap(~generation_moniker)
```

We basically see the same result looking at the age distribution of donors. The
mean of `r mean(customer_segmentation_complete$age_at_last_donation)` and the median
of `r median(customer_segmentation_complete$age_at_last_donation)` are rather apparent.

```{r}
ggplot(customer_segmentation_first_prepro %>% drop_na(age_at_last_donation), aes(age_at_last_donation)) +
  geom_histogram(fill = "#76B856", color = "white", binwidth = 5)
```

Looking at the count of donations we see a very similar picture as we've already
observed looking at the donation sums. This makes sense as there are many single
donors.

```{r}
ggplot(customer_segmentation_first_prepro %>% filter(COUNTtotal < (7 * 6)), aes(COUNTtotal)) +
  geom_histogram(fill = "#76B856", color = "white", binwidth = 1)
```

Looking at the donation interval we get the confirmation that people who donate more
than once donate at very similar times.

```{r}
ggplot(customer_segmentation_first_prepro %>% drop_na(donation_interval) %>% filter(donation_interval < (360 * 5)), aes(donation_interval)) +
  geom_histogram(fill = "#76B856", color = "white", binwidth = 30)
```

It isn't odd to see that looking at the days since the last donation in respect
to a fixed reference date shows the mirror image of the above graph which further
cements our hypothesis that people tend to donate at similar times.

```{r}
ggplot(customer_segmentation_first_prepro, aes(days_since_last_payment)) +
  geom_histogram(fill = "#76B856", color = "white", binwidth = 30)
```

We get a very interesting look at the donation sums when plotting them over the
birth years of the donors. Unfortunately we don't have all the donation data of
donors over their complete lifetime but from this view we could assume that for
most donors there is a plateau sum they will reach over their donor life time. The
cliffs to the left and right will most likely be effects of left- and right-censored
data. As some donations are exremely high we filter out everything six standard
deviations above the mean.

```{r}
mean_total_sum <- customer_segmentation_first_prepro$SUMtotal %>% mean(na.rm = TRUE)
sd_total_sum <- customer_segmentation_first_prepro$SUMtotal %>% sd(na.rm = TRUE)

ggplot(customer_segmentation_first_prepro %>% drop_na(year_born) %>% filter(SUMtotal < (mean_total_sum + sd_total_sum * 6)), aes(year_born, SUMtotal)) +
  geom_point(color = "#76B856", fill = "#76B856", alpha = 1 / 10)
```

As we have additional data on the states in which donors live we could look
at donor counts and sums in respect to their state. Looking at count we would
see widely different numbers. It is important to consider, though, that these
counts should are expected to be different because e.g.: Vienna is the biggest state
so we expect a lot of donors.

```{r}
donors_per_state <- customer_segmentation_first_prepro %>%
  select(Bundesland) %>%
  group_by(Bundesland) %>%
  count() %>%
  ungroup()
  
ggplot(donors_per_state, aes(Bundesland, n)) +
  geom_col(fill = "#76B856")
```

When adjusting the counts to represent donors per 100,000 inhabitants we see an
over representation of Lower Austria and an under representation of Vorarlberg and
Vienna.

```{r}
# taken from https://de.statista.com/statistik/daten/studie/75396/umfrage/entwicklung-der-bevoelkerung-in-oesterreich-nach-bundesland-seit-1996/
pop_vienna <- 1921153
pop_lower_austria <- 1691040
pop_upper_austria <- 1495756
pop_styria <- 1247159
pop_tyrol <- 760161
pop_carithia <- 562230
pop_salzburg <- 560643
pop_vorarlberg <- 399164
pop_burgenland <- 296040

donors_per_state_per_100_000_inhabitants <- donors_per_state %>%
  mutate(
    n = case_when(
      Bundesland == "B" ~ n / pop_burgenland * 100000,
      Bundesland == "K" ~ n / pop_carithia * 100000,
      Bundesland == "N" ~ n / pop_lower_austria * 100000,
      Bundesland == "O" ~ n / pop_upper_austria * 100000,
      Bundesland == "Sa" ~ n / pop_salzburg * 100000,
      Bundesland == "St" ~ n / pop_styria * 100000,
      Bundesland == "T" ~ n / pop_tyrol * 100000,
      Bundesland == "V" ~ n / pop_vorarlberg * 100000,
      Bundesland == "W" ~ n / pop_vienna * 100000
    )
  )

ggplot(donors_per_state_per_100_000_inhabitants, aes(Bundesland, n)) +
  geom_col(fill = "#76B856")
```

Looking at the donation sums we see a similar behavior as we have seen with the counts.
The last visual analysis should have proven to us that this trivial example is not
very useful.

```{r}
sums_per_state <- customer_segmentation_first_prepro %>%
  group_by(Bundesland) %>%
  summarize(sum_donations = sum(SUMtotal)) %>%
  ungroup()

ggplot(sums_per_state, aes(Bundesland, sum_donations)) +
  geom_col(fill = "#76B856")
```

Interestingly, when we look at the sums per inhabitant of a state we see an over
representation of Viennese money while Vorarlberg is even less present.

```{r}
sums_per_state_per_inhabitant <- sums_per_state %>%
  mutate(
    sum_donations = case_when(
      Bundesland == "B" ~ sum_donations / pop_burgenland,
      Bundesland == "K" ~ sum_donations / pop_carithia,
      Bundesland == "N" ~ sum_donations / pop_lower_austria,
      Bundesland == "O" ~ sum_donations / pop_upper_austria,
      Bundesland == "Sa" ~ sum_donations / pop_salzburg,
      Bundesland == "St" ~ sum_donations / pop_styria,
      Bundesland == "T" ~ sum_donations / pop_tyrol,
      Bundesland == "V" ~ sum_donations / pop_vorarlberg,
      Bundesland == "W" ~ sum_donations / pop_vienna
    )
  )

ggplot(sums_per_state_per_inhabitant, aes(Bundesland, sum_donations)) +
  geom_col(fill = "#76B856")
```

If we want to be even more precise when targeting potential donors we could even
adjust the sums by the spending power in each state in respect to the one with the
highest spending power (Lower Austria). Looking at this graph we might want to
look into Tyrol, Vorarlberg and Vienna. While Tyrol and Vienna are appearing to
be rather over represented in respect to money donated Vorarlberg appears to be
seriously underserviced.

```{r}
# taken from https://de.statista.com/statistik/daten/studie/373051/umfrage/kaufkraft-je-einwohner-in-oesterreich-nach-bundeslaendern/
kaufkraft_vienna <- 22659
kaufkraft_lower_austria <- 25615
kaufkraft_upper_austria <- 24728
kaufkraft_styria <- 23981
kaufkraft_tyrol <- 23579
kaufkraft_carithia <- 23833
kaufkraft_salzburg <- 24685
kaufkraft_vorarlberg <- 25535
kaufkraft_burgenland <- 24919

sums_per_state_per_inhabitant_adjusted <- sums_per_state_per_inhabitant %>%
  mutate(
    sum_donations = case_when(
      Bundesland == "B" ~ sum_donations * (1 / (kaufkraft_burgenland / kaufkraft_lower_austria)),
      Bundesland == "K" ~ sum_donations * (1 / (kaufkraft_carithia / kaufkraft_lower_austria)),
      Bundesland == "N" ~ sum_donations,
      Bundesland == "O" ~ sum_donations * (1 / (kaufkraft_upper_austria / kaufkraft_lower_austria)),
      Bundesland == "Sa" ~ sum_donations * (1 / (kaufkraft_salzburg / kaufkraft_lower_austria)),
      Bundesland == "St" ~ sum_donations * (1 / (kaufkraft_styria / kaufkraft_lower_austria)),
      Bundesland == "T" ~ sum_donations * (1 / (kaufkraft_tyrol / kaufkraft_lower_austria)),
      Bundesland == "V" ~ sum_donations * (1 / (kaufkraft_vorarlberg / kaufkraft_lower_austria)),
      Bundesland == "W" ~ sum_donations * (1 / (kaufkraft_vienna / kaufkraft_lower_austria))
    )
  )

ggplot(sums_per_state_per_inhabitant_adjusted, aes(Bundesland, sum_donations)) +
  geom_col(fill = "#76B856")
```

### RFM

RFM segments customers according to three variabless: Recency, Frequency,
Monetary Value. Using the `rfm` package, RFM scores can be computed either on
raw transaction data (one row per transaction), or on aggregated customer data
(one row per customer). For the former, the method `rfm_table_order` can be
used, for the latter either `rfm_table_customer` or `rfm_table_customer2`.
Since our data set represents aggregated customer data, the latter should be
used. It can be computed directly from the raw data upon adding the two
variables `SUMtotal` and `COUNTtotal`:

```{r}
rfm_scores <- customer_segmentation_raw %>%
  
  # create new variables: total donation sum; total number of donations
  mutate(SUMtotal = SUM2015 + SUM2016 + SUM2017 + SUM2018 + SUM2019,
         COUNTtotal = COUNT2015 + COUNT2016 + COUNT2017 + COUNT2018 + COUNT2019,
         LastPaymentDate = as.Date(LastPaymentDate)) %>%
  
  # compute RFM scores
  rfm_table_customer_2(customer_id = ID,
                       n_transactions = COUNTtotal,
                       latest_visit_date = LastPaymentDate,
                       total_revenue = SUMtotal,
                       analysis_date = reference_date)

rfm_scores
```

```{r}
rfm_scores_on_prepro <- customer_segmentation_first_prepro %>% 
  rfm_table_customer_2(customer_id = ID, 
                       n_transactions = COUNTtotal, 
                       latest_visit_date = as.Date(LastPaymentDate), 
                       total_revenue = SUMtotal, 
                       analysis_date = reference_date)

rfm_results_on_prepro <- rfm_scores_on_prepro$rfm %>% as.data.frame()

first_prepro_with_rfm_results <- merge(x = customer_segmentation_first_prepro,
           y = rfm_results_on_prepro,
           by.x = "ID", 
           by.y = "customer_id")

first_prepro_with_rfm_results
```

### Visual inspection of RFM scores:

```{r}
rfm_heatmap(rfm_scores)
```

In the above heatmap, we can see some interesting patterns (**Note:** The higher
the recency score, the more recent the last donation):

- Higher monetary values are characterized by higher donation frequencies and
  more recent donations. There is an obvious cluster of low monetary value for
  frequency values in [1,2] and recency in [1,3]. These might
  be **lost donors**, i.e. customers who donated only a few times, who have not
  donated in a while and are thus unlikely do donate again in the future.
- In the upper left corner, we see very recent customers with low frequency
  (i.e. new donors) who donated sums above average for this recency score. It
  might be worth focusing on them, since they recently demonstrated
  above-average donation willingness. This segment may be called **prospects**.
- In the upper right corner, we can identify frequent and recent donors who
  donated high sums - these are our **donation champions**.
- At the lower right (frequency in [5,5], recency in [1,3]) we see donors who
  frequently donated high sums in the past, but who have not been active
  recently. Their past donation behaviour indicates high donation willingness,
  so we should try to reactive them as donors, because
  we **do not want to loose** them. However, prior to contacting them, we should
  check whether these donors are still alive, because in the EDA we have seen
  that there are some very old donors, who might have passed away in the
  meantime, which would explain the lack of recent donation activity.

There are further, less obvious customer segments in the heatmap. For the sake
of clarity, rather than verbally describing the segments, below we visually
represent the customer segments we believe to have identified in the heatmap: 

```{r, fig.width=4, fig.height=4}
# define data frame with frequency and recency score thresholds for each segment 
heatmap_segments_df <- data.frame(x = c(1, 3, 4.5, 0.5, 0.5, 2, 4),
                                  y = c(1.5, 1.5, 1.5, 3.5, 4.5, 4, 4),
                                  lab = c("Lost", "Loyal average donor at risk", "Don't lose",
                                          "Newbie", "Prospects", "Loyal average donor active",
                                          "Champ"))

# plot the customer segments
ggplot(heatmap_segments_df, aes(x, y, label = lab)) +
  geom_rect(aes(xmin = 0, xmax = 2, ymin = 0, ymax = 3), fill = "red", alpha = 0.1) +
  geom_rect(aes(xmin = 2, xmax = 4, ymin = 0, ymax = 3), fill = "blue", alpha = 0.1) +
  geom_rect(aes(xmin = 4, xmax = 5, ymin = 0, ymax = 3), fill = "green", alpha = 0.1) +
  geom_rect(aes(xmin = 0, xmax = 1, ymin = 3, ymax = 4), fill = "tomato", alpha = 0.1) +
  geom_rect(aes(xmin = 0, xmax = 1, ymin = 4, ymax = 5), fill = "yellow", alpha = 0.1) +
  geom_rect(aes(xmin = 1, xmax = 3, ymin = 3, ymax = 5), fill = "orange", alpha = 0.1) +
  geom_rect(aes(xmin = 0, xmax = 1, ymin = 4, ymax = 5), fill = "cyan", alpha = 0.1) +
  geom_rect(aes(xmin = 3, xmax = 5, ymin = 3, ymax = 5), fill = "magenta", alpha = 0.1) +
  geom_text(size=3)
```

The `rfm_segment` method can be used to assign donors to a given segment based
on their RFM scores. To this end, the upper and lower bounds of recency,
frequency and monetary scores for each segment, as well as the respective
segment names, need to be defined. However, the code below throws an error, so
probably there is a bug in the definition of the lower/upper segment
bounds. **ToDo: Fix the bug, or remove this**.

```{r eval=FALSE, include=FALSE}
segment_names_custom <- c("Champs", "Regular average active", "Prospect", "Newcomer",
                   "Don't loose", "Regular average at risk", "Lost")

recency_lower_2 <-   c(4, 4, 5, 4, 1, 1, 1)
recency_upper_2 <-   c(5, 5, 5, 4, 3, 3, 3)
frequency_lower_2 <- c(4, 2, 1, 1, 5, 3, 1)
frequency_upper_2 <- c(5, 3, 1, 1, 5, 4, 2)
monetary_lower_2 <-  c(4, 1, 4, 1, 4, 3, 1)
monetary_upper_2 <-  c(5, 3, 5, 2, 5, 4, 2)

segment_2 <- rfm_segment(rfm_scores, segment_names = segment_names_custom,
                       recency_lower_2,
                       recency_upper_2,
                       frequency_lower_2,
                       frequency_upper_2,
                       monetary_lower_2,
                       monetary_upper_2)
```

As an alternative to `rfm_segment`, segments can be assigned to donors with the
help of hand-crafted if-else-rules. However, this segmentation is not useful,
because it yields a very high number of donors belonging to the `other` segment
(approx. 25%). The reason for this is probably the aforementioned error in the
definition of the upper/lower segment bounds. 

```{r}
rfm_segments <- rfm_scores$rfm %>% 
  mutate(segment = ifelse(recency_score %in% 4:5 & frequency_score %in% 4:5 & monetary_score %in% 4:5,
                          "Champ",
                          ifelse(recency_score %in% 4:5 & frequency_score %in% 2:3 & monetary_score %in% 1:3,
                          "Regular avg active",
                          ifelse(recency_score %in% 5:5 & frequency_score %in% 1:1 & monetary_score %in% 4:5,
                          "Prospect", 
                          ifelse(recency_score %in% 4:4 & frequency_score %in% 1:1 & monetary_score %in% 1:3,
                          "Newbie", 
                          ifelse(recency_score %in% 1:3 & frequency_score %in% 5:5 & monetary_score %in% 4:5,
                          "Don't loose", 
                          ifelse(recency_score %in% 1:3 & frequency_score %in% 3:4 & monetary_score %in% 3:4,
                          "Regular avg at risk", 
                          ifelse(recency_score %in% 1:3 & frequency_score %in% 1:2 & monetary_score %in% 1:2,
                          "Lost", "Other"))))))))

rfm_segments %>%
  ggplot(aes(segment)) +
  geom_bar()
```

```{r}
rfm_segments$segment %>%
  table() %>%
  prop.table() %>%
  round(3) %>%
  sort(decreasing = T)
```

```{r}
other_peeps <- rfm_segments %>%
  filter(segment == "Other") %>%
  select(customer_id) %>%
  unique() %>%
  (function (x) x$customer_id)

first_prepro_with_rfm_results %>% filter(ID %in% other_peeps)
```

```{r}
# these are the same categories as above, just using the first_prepro data instead of the raw data 
first_prepro_with_rfm_segments <- first_prepro_with_rfm_results %>% 
  mutate(segment = ifelse(recency_score %in% 4:5 & frequency_score %in% 4:5 & monetary_score %in% 4:5,
                          "Champ",
                          ifelse(recency_score %in% 4:5 & frequency_score %in% 2:3 & monetary_score %in% 1:3,
                          "Regular avg active",
                          ifelse(recency_score %in% 5:5 & frequency_score %in% 1:1 & monetary_score %in% 4:5,
                          "Prospect", 
                          ifelse(recency_score %in% 4:4 & frequency_score %in% 1:1 & monetary_score %in% 1:3,
                          "Newbie", 
                          ifelse(recency_score %in% 1:3 & frequency_score %in% 5:5 & monetary_score %in% 4:5,
                          "Don't loose", 
                          ifelse(recency_score %in% 1:3 & frequency_score %in% 3:4 & monetary_score %in% 3:4,
                          "Regular avg at risk", 
                          ifelse(recency_score %in% 1:3 & frequency_score %in% 1:2 & monetary_score %in% 1:2,
                          "Lost", "Other"))))))))

first_prepro_with_rfm_segments
```

As assumed, We're indeed not covering everything here. E.g. somebody with recency
score 4 and frequency score 1 is automatically classified as "other", regardless
of monetary value. But that person could easily be a "Prospect" or "Newbie".
It might therefore be wise to use the bounds recommended by introductions to rfm.

```{r}
first_prepro_with_rfm_segments %>% filter(segment == "Other") %>% 
  ggplot(aes(frequency_score, recency_score)) +
  geom_tile(aes(fill = monetary_score), colour = "white") +
  scale_fill_distiller(palette = "PuBu", direction = +1) +
  labs(title="heatmap only on those classified as OTHER in Michael's first try") +
  theme_minimal()
```

The above heatmap shows that we e.g. missed a lot of "big donors" in the first attempt.

To remedy the faulty segmentation shown above, we resort to the customer
segments (and the respective RFM score thresholds) presented in class (see slide
deck of first class, p. 82 as well as [here](https://rpubs.com/Eddie_Zaldivar/705462).
We use this mainstream segmentation as our baseline:

```{r}
# define name of each segment
segment_names_baseline <- c("Champions", "Loyal Customers", "Potential Loyalist",
  "New Customers", "Promising", "Need Attention", "About To Sleep",
  "At Risk", "Can't Lose Them", "Lost")

# set the upper and lower bounds for recency, frequency, and monetary for each segment
recency_lower <- c(4, 2, 3, 4, 3, 2, 2, 1, 1, 1)
recency_upper <- c(5, 5, 5, 5, 4, 3, 3, 2, 1, 2)
frequency_lower <- c(4, 3, 1, 1, 1, 2, 1, 2, 4, 1)
frequency_upper <- c(5, 5, 3, 1, 1, 3, 2, 5, 5, 2)
monetary_lower <- c(4, 3, 1, 1, 1, 2, 1, 2, 4, 1)
monetary_upper <- c(5, 5, 3, 1, 1, 3, 2, 5, 5, 2)

# assign segment to each customer
rfm_segments_baseline <- rfm_segment(rfm_scores,
                                     segment_names_baseline,
                                     recency_lower,
                                     recency_upper,
                                     frequency_lower, 
                                     frequency_upper, 
                                     monetary_lower,
                                     monetary_upper)

# inspect segment assignment
head(rfm_segments_baseline)
```

```{r}
# NOW ON PREPRO DATA and using numeric customer_id

# assign segment to each customer
rfm_segments_baseline_on_prepro <- rfm_segment(rfm_scores_on_prepro,
                                     segment_names_baseline,
                                     recency_lower,
                                     recency_upper,
                                     frequency_lower, 
                                     frequency_upper, 
                                     monetary_lower,
                                     monetary_upper)

# merge with prepro_data
rfm_results_baseline_on_prepro <- merge(x = customer_segmentation_first_prepro,
           y = rfm_segments_baseline_on_prepro,
           by.x = "ID", 
           by.y = "customer_id")

# inspect segment assignment
head(rfm_results_baseline_on_prepro)
```

The mainstream customer segmentation is better as our own approach since it
yields much less `other` instances (only approximately 6.3% of donors are
assigned to this segment):

```{r}
rfm_results_baseline_on_prepro %>% ggplot(aes(segment)) + 
  geom_bar()
```

```{r}
rfm_results_baseline_on_prepro$segment %>%
  table() %>%
  prop.table() %>%
  round(2) %>%
  sort(decreasing = T)
```

```{r}
rfm_results_baseline_on_prepro$segment %>%
  table() %>%
  prop.table() %>%
  round(3) %>%
  sort(decreasing = T)
```

Finally, we can inspect median scores for each RFM component per segment:

```{r}
rfm_plot_median_recency(rfm_results_baseline_on_prepro)
```

```{r}
rfm_plot_median_frequency(rfm_results_baseline_on_prepro)
```

```{r}
rfm_plot_median_monetary(rfm_results_baseline_on_prepro)
```
